%%% -*- Mode: LaTeX; -*-
%       RCS: $Id: README.tex,v 1.2 2017-12-26 16:35:03 lsipusr Exp $

%%%#+BEGIN: bx:dblock:lcnt:warning-intro :class "memo" :langs "en+fa"

%%%#+END:

%%%#+BEGINNOT: bx:dblock:lcnt:header-begin :class "memo" :langs "en+fa"
%{{{ DBLOCK-header-begin

\documentclass{article}

\usepackage{hevea} 
%HEVEA\usepackage[utf8]{inputenc}

\htmlhead{
\vspace{0.4in}
}

\htmlfoot{
\bigskip
}


\usepackage{fontspec}
\setmainfont[Mapping=tex-text]{Linux Libertine O}

\usepackage{morefloats}

\usepackage{rcs}
\usepackage{makeidx}
\usepackage{supertabular}
\usepackage{lscape}
\usepackage{array} 
\usepackage{framed}
\usepackage{listings}

\usepackage{color}

\usepackage{hyperref}
\usepackage{url}

\usepackage{fancyhdr}

\usepackage{caption}

\usepackage{fontspec}
\usepackage{xltxtra}
\usepackage{xunicode}

%}}} DBLOCK-header-begin
%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:style-params :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: style-params*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}
% ===== STYLE PARAMETERS =====

\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}

\hypersetup{
    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={My title},    % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true ,       % false: boxed links; true: colored links
    linkcolor=darkblue,     % color of internal links
    citecolor=red,          % color of links to bibliography
    filecolor=darkgreen,    % color of file links
    urlcolor=darkred        % color of external links
}


\setlength{\textwidth}{6.0in}
\addtolength{\oddsidemargin}{-0.75in}
\addtolength{\evensidemargin}{-0.75in}

\topmargin      0.00 in
\textheight     8.50 in

\setlength{\textwidth}{16.5cm}
\setlength{\topmargin}{-0.3in}
\setlength{\textheight}{8.5in}
\setlength{\oddsidemargin}{0.0cm}
\setlength{\evensidemargin}{0.0cm}


\pagestyle{fancy}
\fancyhead{} % clear all header fields  
%% \fancyhead[C]{{\small  {\tt Work In Progress}}}
\renewcommand{\headrulewidth}{0pt} % no line in header area
\fancyfoot{} % clear all footer fields
%%\fancyfoot[LE,RO]{\thepage}           % page number in "outer" position of footer line
%% \fancyfoot[RE,LO]{{\tt --EARLY DRAFT DOCUMENT--\hspace{20 mm} --Reflects Work In Progress-- }}
\fancyfoot[RE,LO]{}


\parindent 0 true pc

\addtolength{\parskip}{5pt}


%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:header-end :class "memo" :langs "en+fa"
%{{{ DBLOCK-header-end

\begin{document}
%}}} DBLOCK-header-end
%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:front-begin :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: front-begin*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}

%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:copyright :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: copyright*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}

%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:front-end :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: front-end*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}

%%%#+END:

%%%#+BEGINNOT: bx:dblock:lcnt:main-begin :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: main-begin*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}

\title{unisos.wsfClassicCars}

%%%#+END:

\thispagestyle{empty}


\bigskip

\section{Overview}

unisos.wsfClassicCars: Classic Cars App Based On WSF (Web Scraping Framework)

\section{Support}

For support, criticism, comments and questions; please contact the 
author/maintainer \\
\href{http://mohsen.1.banan.byname.net}{Mohsen Banan} at: \url{http://mohsen.1.banan.byname.net/contact}


\section{Documentation}

This unisos.wsfClassicCars module is usage example of unisos.wsf.

For details of Web Scraping Framework (wsf), see that module's documentation.

WSF is a general purpose scraping engine module.
unisos.wsfClassicCars applies to scraping:\\
\url{https://www.oldclassiccar.co.uk/forum/phpbb/phpBB2/viewtopic.php?t=12591}
in specific.

\section{Installation}

From the git repo, go to the wsfClassicCars/py3 directory.

\begin{verbatim}
Run: ./setup.py sdist
\end{verbatim}

\begin{verbatim}
Run: pip install --no-cache-dir ./dist/unisos.wsfClassicCars-0.1.tar.gz
\end{verbatim}

From PyPi:

\begin{verbatim}
Run: pip install --no-cache-dir unisos.wsfClassicCars
\end{verbatim}


4 file will be created in your venv/bin directory.
These are copies of the ones in the ./bin directory.

\section{Usage}

In wsfClassicCars/py3,
the following files control and run the wsfClassicCars scraper.

\begin{description}
  \item[./bin/classicCarsScraperParams.py:]
        This is the configuration file for this App.
        WSF uses python function invocation as the configuration syntax.
        Even for those unfamiliar with Python, the syntax is intuitive.
        You can modify these parameters to your liking.

  \item[./bin/scraperClassicCars.py:]
        This is the class that implements the concrete class that scrapes the inputs.

        The last invocation in that file:


\begin{verbatim}
 wsf_config.scrapingProcessor(
    scraperClass=ClassicCars,
)
\end{verbatim}

        passes:

\begin{verbatim}
class ClassicCars(wsf_scraperMultipage.ScraperMultipage):
\end{verbatim}

        to the config machinery.

  \item[./bin/scrapeExample.py:]
        This is example of how to run the scraper in full, minimally.

        The entire relevant code is:

\begin{verbatim}
import classicCarsScraperParams
import scraperClassicCars

from unisos.wsf import wsf_parallelProc

if __name__ == '__main__':
    wsf_parallelProc.dispatchWorkersUsingParams()
\end{verbatim}

        The first two imports bring over the concrete class and set configuration parameters.

        The main entry to wsf is wsf\_parallelProc.dispatchWorkersUsingParams()

  \item[./bin/icmClassicCarsWebScraper.py:]
        This is the preferred way of running this App on the command line.

        Running the ICM (Interactive Command Module) by itself as:
\begin{verbatim}
icmClassicCarsWebScraper.py
\end{verbatim}

        Gives you a list of commands that you can pick and run.

        Choose:
\begin{verbatim}
 icmClassicCarsWebScraper.py  --load classicCarsScraperParams.py
--load scraperClassicCars.py  -i scrape
\end{verbatim}

        (run all of it in one line.)


        Parameters and the concrete class are first loaded, then the ``scrape'' command is executed.

        For debugging purposes, if needed, you can enable verbosity and callTracking with:

\begin{verbatim}
icmClassicCarsWebScraper.py -v 1 --callTrackings monitor+ --callTrackings invoke+
 --load classicCarsScraperParams.py --load scraperClassicCars.py  -i scrape
\end{verbatim}

        (run all of it in one line.)

\end{description}



\bigskip

\section{Context And History}

I, Mohsen BANAN, have put togther this as a sample of my python code.

It is about writing a scraper for\\
\url{https://www.oldclassiccar.co.uk/forum/phpbb/phpBB2/viewtopic.php?t=12591}

I could use a web scraper development framework for a project
that I was doing and decided to make this part of it public.

Here is the process that I went through to put this together in 2020.


\section{Initial Web Searches}

I first searched the web to see if this, or something similar, has been done before.
I found the following relevant pointers:

\begin{itemize}
  \item \url{https://github.com/nneibaue/yukon_cornelius}

        This is a scraper for oldclassiccar.co.uk.

        The design and modeling quality is not great. But the
        code and some the design is re-usable and I have used it. Later, I'll revisit these.

  \item \url{https://stackoverflow.com/questions/56211202/attributeerror-str-object-has-no-attribute-keys-when-trying-to-use-writerow}

  Nothing useful there.

  \item PyPi Web Scraping Engines/Tools/Packages.

  There are several there. But I did not find any that I liked.

\end{itemize}


\section{The ``Web Scraping Development Framework'' Model}

I decided to build a web scraping development framework and then
immediately use it for my own projects and also have it scrape
oldclassiccar.co.uk.

Very much by choice, I avoided calling it a ``web scraping engine''.
The domain of web scraping is too broad and too diverse to be
reasonably codified as an ``engine''.

Using web scraping development framework (wsdf), a developer can
quickly customize the specifics of a particular site's scraping.
The common aspects of web scraping go into wsdf.

\section{About unisos.wsf}

unisos.wsf is a pip package included in this repo.

It is a generalized scraping framework that can be considered a
public resource. There is nothing in wsf which is specific to
oldclassiccar.co.uk or any other site in there.

In this case, unisos is just a namespace to avoid name conflicts.

\section{About unisos.wsfClassicCars}

unisos.wsfClassicCars is also a pip package.
unisos.wsfClassicCars uses unisos.wsf.

The code in unisos.wsfClassicCars is very minimal.

Configuration file, the concrete ClassicCars class and the executable are all in the bin directory.

\section{About Contents Of This Repo}

After untar-ing, you will have two directories.

\begin{itemize}
  \item wsf
  \item wsfClassicCars
\end{itemize}

There are two files that you need to read.

\begin{enumerate}
  \item wsfClassicCars/py3/README.pdf
  \item wsf/py3/README.pdf
\end{enumerate}

\section{Installation}

I have tested these with Python 3.9.
Both packages will likely work fine with earlier Python 3.x release.

Create a fresh virtual environments. Install the two packages by
following these instructions:

\begin{enumerate}
  \item Go to wsf/py3. Follow the instructions in READEME.pdf Section 4.2.
  \item Go to wsfClassicCars/py3. Follow the instructions in READEME.pdf Section 4.
\end{enumerate}

The ``requires'' section of wsf/py3/setup.py enumerates all other
package dependencies.

A pip list after the installation should produce something like:

\begin{verbatim}
Package               Version
--------------------- ---------
beautifulsoup4        4.10.0
certifi               2021.10.8
charset-normalizer    2.0.7
enum34                1.1.10
idna                  3.3
lxml                  4.6.4
pip                   21.3.1
requests              2.26.0
setuptools            58.3.0
soupsieve             2.3.1
unisos.icm            0.25
unisos.ucf            0.15
unisos.wsf            0.1
unisos.wsfClassicCars 0.1
urllib3               1.26.7
wheel                 0.37.0
\end{verbatim}

\section{About unisos.icm}

I want Web Scraping Application (WS-Apps) to function as plug-able modules on the command line interface.

unisos.wsfClassicCars is a WS-App.

ICM (Interactive Command Modules) is a pip package that I have developed.
It is similar to ``click'' but it also supports ``--load fileName''.
fileName can be any python code. This is how wsfClassicCars becomes a plug-able command line module.

Also, the flexibility that ICM provides allows for regression testing of whole or parts of the code.
This renders the usual traditions of unit testing obsolete.

\section{About COMEEGA And Dynamic Blocks}

Parts of my code are written as COMEEGA.
COMEEGA stands for ``Collaborative Org-Mode Enhanced Emacs Generalized Authorship''.
Think of it as inverse of Literate Programming. Where the code is also a document.
You can switch between code mode and document mode by switching between org-mode and python-mode.

Without emacs and org-mode, such code is not pleasant.
I wont use COMEEGA on other people's code.

Dynamic Blocks are a feature of org-mode. What is between +BEGIN: and +END: is
controlled with lisp code and will be overwritten if edited.

This allows me to add visible macro capabilities to python.

Both COMEEGA and Dynamic Blocks are mostly used in
icmClassicCarsWebScraper.py. If you view that as un-pleasant, I
suggest that you just consider it as awareness of other powerful ways
of doing things ...


\section{Design And Implementation Considerations}

I did all of this on a rush basis. So, the code is weak in terms of error handling and robustness.
But, there is a proper starting point in place and over time it can improve and expand.




%%%#+BEGIN: bx:dblock:lcnt:main-end :class "memo" :langs "en+fa"
\begin{comment}
*  [[elisp:(org-cycle)][| ]]  *DBLK: main-end*                                       :: [[elisp:(beginning-of-buffer)][Top]] [[elisp:(delete-other-windows)][(1)]]  [[elisp:(org-cycle)][| ]]
\end{comment}

\end{document}

%%%#+END:

%%%#+BEGIN: bx:dblock:lcnt:latex:end-of-file :class "memo" :langs "en+fa"
%local variables:
%major-mode: latex-mode
%folded-file: nil
%fill-column: 65
%TeX-master: ""
%End:
%%%#+END:
